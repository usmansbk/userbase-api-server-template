enum AccountStatus {
  """
  Accounts have a staged status when they are first created, before the activation flow is initiated, or if there is a pending admin action.
  """
  Staged

  """
  Accounts have a provisioned status when the user has not provided verification by clicking through the activation email.
  """
  Provisioned

  """
  Accounts have an active status when:
  - An admin adds a user and sets the user password without requiring email verification.
  - A user self-registers and verified their email.
  - An admin explicitly activate user accounts.
  """
  Active

  """
  Accounts have a recovery status when a user requests a password reset or an admin initiates one on their behalf.
  """
  Recovery

  """
  Accounts have a password expired status when the password has expired and the account requires an update to the password before a user is granted access to applications.
  """
  PasswordExpired

  """
  Accounts have a locked out status when the user exceeds the number of login attempts.
  """
  LockedOut

  """
  Accounts have a suspended status when an admin explicitly suspends them. The user cannot access applications.
  """
  Suspended

  """
  Accounts have a deprovisioned status when an admin explicitly deactivates or deprovisions them. All application assignments are removed and the password is permanently deleted.
  """
  Deprovisioned
}

type User {
  id: ID!
  firstName: String!
  lastName: String
  surname: String
  email: EmailAddress!
    @auth(
      rules: [
        { allow: owner, ownerField: "id" }
        { allow: roles, roles: ["Admin"] }
        { allow: permissions, permissions: ["ReadUserEmail"] }
      ]
    )
  language: Locale!
  phoneNumber: PhoneNumber
    @auth(
      rules: [
        { allow: owner, ownerField: "id" }
        { allow: roles, roles: ["Admin"] }
        { allow: permissions, permissions: ["ReadUserPhoneNumber"] }
      ]
    )
  isEmailVerified: Boolean!
  isPhoneNumberVerified: Boolean!
  isMe: Boolean!
  socialPictureUrl: URL
  picture: UserAvatar
  createdAt: DateTime!
  updatedAt: DateTime
  passwordUpdatedAt: DateTime
  roles: [String]!
  status: AccountStatus
  sessions: [UserSession]!
    @auth(
      rules: [
        { allow: owner, ownerField: "id" }
        { allow: roles, roles: ["Admin"] }
        { allow: permissions, permissions: ["ReadSession"] }
      ]
    )

  rolesCreatedByUser: [Role]! @auth(rules: [{ allow: roles, roles: ["Admin"] }])

  permissionsCreatedByUser: [Permission]!
    @auth(rules: [{ allow: roles, roles: ["Admin"] }])

  rolesAssignedToUser: [UserRole]!
    @auth(rules: [{ allow: roles, roles: ["Admin"] }])

  rolesAssignedByUser: [UserRole]!
    @auth(rules: [{ allow: roles, roles: ["Admin"] }])

  permissionsAssignedToUser: [UserPermission]!
    @auth(rules: [{ allow: roles, roles: ["Admin"] }])

  permissionsAssignedByUser: [UserPermission]!
    @auth(rules: [{ allow: roles, roles: ["Admin"] }])

  rolePermissionsAssignedByUser: [RolePermission]!
    @auth(rules: [{ allow: roles, roles: ["Admin"] }])
}

type UserAvatar {
  id: ID!
  picture: Picture!
  createdAt: DateTime!
  updatedAt: DateTime
}

type UserSession
  @auth(
    rules: [
      { allow: owner }
      { allow: roles, roles: ["Admin"] }
      { allow: permissions, permissions: ["ReadSession"] }
    ]
  ) {
  id: ID!
  jti: ID!
  clientId: ID!
  clientIp: IP!
  createdAt: DateTime!
  userAgent: String
}

"""
Essentially, a role is a collection of permissions that you can apply to users.
Using roles makes it easier to add, remove, and adjust permissions than assigning permissions to users individually.
As your user base increases in scale and complexity, roles become particularly useful.
"""
type Role
  @auth(
    rules: [
      { allow: roles, roles: ["Admin"] }
      { allow: permissions, permissions: ["ReadRole"] }
    ]
  ) {
  id: ID!
  name: String!
  creator: User
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
  userRoles: [UserRole]!
  rolePermissions: [RolePermission]!
}

type Permission
  @auth(
    rules: [
      { allow: roles, roles: ["Admin"] }
      { allow: permissions, permissions: ["ReadPermission"] }
    ]
  ) {
  id: ID!
  name: String!
  creator: User
  description: String
  createdAt: DateTime!
  updatedAt: DateTime
  userPermissions: [UserPermission]!
  rolePermissions: [RolePermission]!
}

type UserRole
  @auth(
    rules: [
      { allow: roles, roles: ["Admin"] }
      { allow: permissions, permissions: ["ReadRole"] }
    ]
  ) {
  id: ID!
  role: Role!
  assignee: User!
  assignor: User
  createdAt: DateTime!
  updatedAt: DateTime
}

type UserPermission
  @auth(
    rules: [
      { allow: roles, roles: ["Admin"] }
      { allow: permissions, permissions: ["ReadPermission"] }
    ]
  ) {
  id: ID!
  permission: Permission!
  assignee: User!
  assignor: User
  createdAt: DateTime!
  updatedAt: DateTime
}

type RolePermission
  @auth(
    rules: [
      { allow: roles, roles: ["Admin"] }
      { allow: permissions, permissions: ["ReadPermission"] }
    ]
  ) {
  id: ID!
  role: Role!
  permission: Permission!
  assignor: User
  createdAt: DateTime!
  updatedAt: DateTime
}

type Query {
  me: User! @auth
}

type AuthResponse implements Response {
  success: Boolean
  message: String
  """
  Access tokens contain information about what scopes, or permissions.
  """
  accessToken: JWT
  """
  Token used to obtain a renewed Access Token without forcing users to log in again.
  """
  refreshToken: JWT
}

type UserResponse implements Response {
  success: Boolean
  message: String
  user: User!
}

enum IdentityProvider {
  GOOGLE
}

input IdentityProviderLoginInput {
  provider: IdentityProvider!
  token: NonEmptyString!
}

input EmailLoginInput {
  email: EmailAddress!
  password: NonEmptyString!
}

input EmailOTPLoginInput {
  email: EmailAddress!
  otp: NonEmptyString!
}

input SMSOTPLoginInput {
  phoneNumber: PhoneNumber!
  otp: NonEmptyString!
}

input RegisterWithEmailInput {
  firstName: NonEmptyString!
  lastName: NonEmptyString
  surname: NonEmptyString
  email: EmailAddress!
  password: NonEmptyString!
  phoneNumber: PhoneNumber
  language: Locale
}

input UpdateBasicInfoInput {
  firstName: NonEmptyString!
  lastName: NonEmptyString
  surname: NonEmptyString
  language: Locale
}

input ResetPasswordInput {
  password: NonEmptyString!
  token: NonEmptyString!
}

input VerifyPhoneNumberInput {
  phoneNumber: PhoneNumber!
  token: NonEmptyString!
}

input VerifyNewEmailInput {
  email: EmailAddress!
  token: NonEmptyString!
}

input DeleteAccountInput {
  password: NonEmptyString!
  token: NonEmptyString!
}

input UpdatePhoneNumberInput {
  phoneNumber: PhoneNumber!
}

input VerifyEmailInput {
  token: NonEmptyString!
}

type Mutation {
  joinWaitlist(email: EmailAddress!): MutationResponse!
  leaveWaitlist(token: NonEmptyString!): MutationResponse!

  loginWithIdentityProvider(input: IdentityProviderLoginInput!): AuthResponse!

  registerWithEmail(input: RegisterWithEmailInput!): AuthResponse!
  loginWithEmail(input: EmailLoginInput!): AuthResponse!

  requestEmailLoginOTP(email: EmailAddress!): MutationResponse!
  loginWithEmailOTP(input: EmailOTPLoginInput!): AuthResponse!

  requestSMSLoginOTP(phoneNumber: PhoneNumber!): MutationResponse!
  loginWithSMSOTP(input: SMSOTPLoginInput!): AuthResponse!

  requestUserPhoneNumberVerification(
    phoneNumber: PhoneNumber!
  ): MutationResponse!
  verifyUserPhoneNumber(input: VerifyPhoneNumberInput!): MutationResponse!

  requestUserEmailVerification(email: EmailAddress!): MutationResponse!
  verifyUserEmail(input: VerifyEmailInput!): MutationResponse!

  requestResetUserPassword(email: EmailAddress!): MutationResponse!
  resetUserPassword(input: ResetPasswordInput!): MutationResponse!

  removeCurrentUserPicture: UserResponse!
    @auth(rules: [{ allow: status, status: [Provisioned, Active] }])
  updateCurrentUserBasicInfo(input: UpdateBasicInfoInput!): UserResponse!
    @auth(rules: [{ allow: status, status: [Provisioned, Active] }])
  updateCurrentUserPhoneNumber(input: UpdatePhoneNumberInput!): UserResponse!
    @auth(rules: [{ allow: status, status: [Provisioned, Active] }])

  logoutFromAllDevices: MutationResponse! @auth
  requestDeleteCurrentUserAccount: MutationResponse!
    @auth(rules: [{ allow: status, status: [Provisioned, Active] }])
  deleteUserAccount(input: DeleteAccountInput!): MutationResponse!
}
